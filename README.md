## 目录

  - Arduino介绍
    - 语言与IDE介绍
    - 硬件参数
    - 语言语法概况
    - Arduino关键词
    - 算法
      - PID算法

## Arduino介绍

### 语言与IDE介绍

语言为偏C语言的语法。C语言的延伸或者说是分支，所以学C/C++也是一样的。

拥有这些硬件专用的函数是因为Arduino自带的，本质是为以Wiring为基础的电子设计核心库组合而成。

.ino文件如果要打开文件名就不能带中文字符，所处文件路径可以含有中文字符。.ino是Arduino源码文件的后缀名。

询问“移动到文件夹并打开”实际上会在ino原文件的目录创建一个文件夹，此文件夹只有这个ino文件，原因未知。

Arduino IDE可以使用com串口通信（电脑的端口名，com后面的数字依电脑不同而不同）进行模拟的输入输出，可以看到模拟的执行结果。

***

Arduino电路板设计使用各种微处理器和控制器。这些电路板配有一组数字和模拟输入/输出（I/O）引脚，可以连接各种扩展板或面包板（屏蔽板）和其他电路。这些电路板具有串行通信接口，包括某些型号上的通用串行总线（USB），也用于从个人计算机加载程序。微控制器通常使用C/C++编程语言。除了使用传统的编译工具链之外，Arduino项目还提供了一个基于Processing语言项目的集成开发环境（IDE），就叫“Arduino”。

它使用 Atmel AVR 单片机，采用开放源代码的软硬件平台，构建于开放源代码 simple I/O 接口板，并具有使用类似 Java，C 语言的 Processing/Wiring 开发环境。软件本身为Java编写，编译器为C/C++语言的编译器，加上自带的以Wiring为基础的电子设计核心库。

### 硬件参数

- Digital I/O 数字输入/输出端口0—13。也就是说0~13的端口均可以进行数字输入和输出。其中，带有～的端口（3、5、6、9、10、11，其中3兼作中断口）可以进行模拟输出。

- Analog I/O 模拟输入端口0-5。也就是说只有0~5的端口可以进行真正的模拟输入。同时，它也可以当作数字输出/输入端口使用。

- 支持ICSP下载（在线烧录），支持TX/RX。

- 输入电压：USB接口供电或者5V-12V外部电源供电。Arduino板子有USB接口以进行5V的供电，另外有提供外部直流电源（5V~12V）的输入口。

- 输出电压：支持3.3V以及5V的直流输出。

- 处理器：使用Atmel Atmega168 328处理器，因其支持者众多，已有公司开发出来32位的MCU平台支持arduino。

- VIN端口：VIN是Input Voltage的缩写，表示有外部电源时的输入端口。

- AREF:Reference voltage for the analog inputs(模拟输入的基准电压）。使用analogReference()命令调用。

- ICSP：也有称为ISP（In System Programmer)，就是一种线上即时烧录，目前比较新的芯片都支持这种烧录模式，其实就是脱离传统的拆出烧录而焊死就不能动的不方便性和缺陷。

我们都知道传统的烧录方式，都是将被烧录的芯片，从线路板上拔起。有的焊死在线路板上的芯片，还得先把芯片焊接下来才能烧录。

Arduino只需要准备一条R232线（连接烧录器），以及一条连接烧录器与烧录芯片针脚的连接线就可以。电源的+5V，GND，两条负责传输烧录信息的针脚，再加上一个烧录电压针脚，这样就可以烧录了。

板部件说明：

![aHR0cHM6Ly9hdHRzLnczY3NjaG9vbC5jbi9hdHRhY2htZW50cy90dXBsb2Fkcy9hcmR1aW5vL2JvYXJkX2Rlc2NyaXB0aW9uLmpwZw.png](/_resources/aHR0cHM6Ly9hdHRzLnczY3NjaG9vbC5jbi9hdHRhY2htZW50cy.png)

1.电源USB：Arduino板可以通过使用计算机上的USB线供电。你需要做的是将USB线连接到USB接口。

2.电源（桶插座）Arduino板可以通过将其连接到电影插口直接从交流电源供电。在脱离计算机的环境中更为常用。

3.稳压器：稳压器的功能是控制提供给Arduino板的电压，并稳定处理器和其他元件使用的直流电压。Arduino自带稳压器，稳压器损坏则大概率会烧板。

4.晶体振荡器：晶振帮助Arduino处理时间问题。Arduino如何计算时间？答案是，通过使用晶体振荡器。在Arduino晶体顶部打印的数字是16.000H9H。它告诉我们，频率是16,000,000赫兹或16MHz。

5、17. Arduino重置：你可以重置你的Arduino板，例如从一开始就启动你的程序。可以通过两种方式重置UNO板。首先，通过使用板上的复位按钮（17）。其次，你可以将外部复位按钮连接到标有RESET（5）的Arduino引脚。

6、7、8、9. 引脚:（3.3，5，GND，Vin）

3.3V（6） - 提供3.3输出电压
5V（7） - 提供5输出电压
(使用3.3伏和5伏电压，与Arduino板一起使用的大多数组件可以正常工作。)
GND（8）（接地） - Arduino上有几个GND引脚，其中任何一个都可用于将电路接地。
VVin（9） - 此引脚也可用于从外部电源（如交流主电源）为Arduino板供电。

10.模拟引脚:Arduino UNO板有六个模拟输入引脚，A0到A5。这些引脚可以从模拟传感器（如湿度传感器或温度传感器）读取信号，并将其转换为可由微处理器读取的数字值。

11.微控制器:每个Arduino板都有自己的微控制器（11）。你可以假设它作为板的大脑。Arduino上的主IC（集成电路）与板对板略有不同。微控制器通常是ATMEL公司的。在从Arduino IDE加载新程序之前，你必须知道你的板上有什么IC。此信息位于IC顶部。有关IC结构和功能的更多详细信息，请参阅数据表。

12.ICSP引脚:大多数情况下，ICSP（12）是一个AVR，一个由MOSI，MISO，SCK，RESET，VCC和GND组成的Arduino的微型编程头。它通常被称为SPI（串行外设接口），可以被认为是输出的“扩展”。实际上，你是将输出设备从属到SPI总线的主机。

13.  电源LED指示灯:  当你将Arduino插入电源时，此LED指示灯应亮起，表明你的电路板已正确通电。如果这个指示灯不亮，那么连接就出现了问题。

14.TX和RX LED:在你的板上，你会发现两个标签：TX（发送）和RX（接收）。它们出现在Arduino UNO板的两个地方。首先，在数字引脚0和1处，指示引脚负责串行通信。其次，TX和RX LED（13）。发送串行数据时，TX LED以不同的速度闪烁。闪烁速度取决于板所使用的波特率（设备为电脑则为9600）。RX在接收过程中闪烁。

15.  数字I/O:  Arduino UNO板有14个数字I/O引脚（15）（其中6个提供PWM（脉宽调制）输出），这些引脚可配置为数字输入引脚，用于读取逻辑值（0或1） ；或作为数字输出引脚来驱动不同的模块，如LED，继电器等。标有“〜”的引脚可用于产生PWM。

16.  AREF:  AREF代表模拟参考。它有时用于设置外部参考电压（0至5伏之间）作为模拟输入引脚的上限。

17.RESET：为复位按钮，拓展板上也有，按下可以使程序停止，再次按下可以重新开始执行程序。

***

### 语言语法概况

使用Arduino Software IDE编写的程序被称为“sketch”。一个典型的Arduino C/C++ sketch程序会包含两个函数，它们会在编译后合成为main()函数：

setup()：在程序运行开始时会运行一次，用于初始化设置。

loop()：直到Arduino硬件关闭前会重复运行函数放的代码。

Arduino有自带不需要声明的硬件操控库，也有需要声明的硬件操控库。

Arduino 程序可由五个部分组成 :

1. 导入库与定义 (可有可无)

#include <SoftEasyTranfer.h>

#define LEDPIN 13;

2. 声明常量与全域变量 (可有可无)

const float PI=3.14159;

int r=0 ;

3. 初始化函数setup（） (必要)

void setup() {}

4. 循环函数loop（）  (必要)

void loop() {}

5. 自定义函数 (可有可无)

float area(float r)
 {
  float a=PI*r*r;
  return a;
  }//C/C++语法

其中 setup() 与 loop() 是一定要有的函数 (均无参数无传回值)，其他则视需要而定。

***

### Arduino关键词

Arduino 语言采用 C/C++ 语法，加上以 Wiring 为基础的电子设计核心库组合而成,，包括 Digital I/O, Analog I/O 等库.，内置的库可直接调用,，但若有使用第三方库(例如驱动感测器模块所需的库),，则必须使用 include 前置指令引入。此外，也可以用前置指令 define 定义一个常量或宏 (表达式)。

前置指令乃 C 编译器指令, 不属于 C 语言本身, 其用途有三 :

引入头文件 : 例如 #include <myLibrary.h> 或 "myLibrary.h"

定义接口（间接）：例如#define Motorright 8，用常量来代替之后的声明

定义常量 : 例如 #define PI 3.14159

定义宏 : 例如 #define AREA(r) PI*r*r

所以前置指令的功能一言以蔽之就是替换, include 就是在标头处以指定之文件内容替换; 而 #define 就是在程序中用到所定义之常量与宏名称时, 以其内容替换.

宏的功能事实上与函数类似, 不同之处是函数调用使用堆栈, 而宏则是直接放在源代码中,由编译器自动进行替换，运行效率较快 (但若很多地方都要用到时, 编译后就会比较大).

注意：头文件可用角括号 < > 或双引号 "", 差别是：

1. 用双引号时, 前置处理器会先从源文件所在位置开始去搜索头文件;

2. 而用角括号则会先从 libraries 目录开始找。

***

数据类型：

void   空变量，只用于函数声明

boolean   布尔变量，占用一个字节的内存

char   字符变量，把字符存储为数字，可进行算术运算。占用一个字节的内存

unsigned char   无符号字符变量，占用一个字节的内存

byte   一个字节，存储一个8位无符号整数，占用一个字节的内存

int   整型变量，因板子型号的不同而占用不同字节的内存（2和4）

unsigned int   无符号整型变量，因板子型号的不同而占用不同字节的内存（2和4）

word   存储一个无符号数，因板子型号的不同而占用不同字节的内存（2和4）

long   长整型变量，占用4个字节的内存

unsigned long   无符号长整型变量，占用4个字节的内存

short   16位数据类型，占用2个字节的内存

float   单精度浮点数变量，占用四个字节的内存

double   双精度浮点数变量，因板子型号的不同而占用不同字节的内存（4和8）

array   数组

string-char array   字符串数组

string-object   字符串对象

uint8_t   无符号字符型（_t代表typedef也就是头文件的定义类型）

uint16_t   无符号整型（_t代表typedef也就是头文件的定义类型）

标准常量：

HIGH、LOW   引脚的电压定义（高电平和低电平）

INPUT、OUTPUT   数字引脚定义

true、output   逻辑层定义

继承自C语言的关键词：

（1）if(expression){}//与C++中的也一致

（2）x=（type）expression;//等于是创建了一个新变量将转换了类型后的表达式的值赋给它，原本变量的位置和值都不变。

宏（等于一种不声明类型的设置常量，一次设置下面代码全部适用）：

（1）#define 宏名 常量值（常量值可以是变量、整数、浮点数、字符串、表达式，都可以，之间只用空格隔开而不需要引号之类的符号，而如果常量值为空则需要在编译器中预先定义这个宏名对应的常量值）

实例：

#define LED=13 //通过定义常量，间接定义针脚，之后直接写LED

#define Pi 3.14 //常量

#define A IamSuperMan //字符串

#define B pi*r*r //表达式

#define ABC //无常量值，因为定义在“预处理器定义”中

#define sum(x) x+x//表达式，"sun(x)"是宏名，常量值也可以(x)+(x)避免x中带有乘号之类的让最终组合的值不一样。

（2）#ifndef 宏名（条件编译）

实例：

#ifndef x 常量值

//先测试x是否被宏定义过

#define x 常量值

//如果没有宏定义下面就宏定义x并编译下面的语句

...

#endif

//如果已经定义了则编译#endif后面的语句

（3）#undef 宏名

//撤销宏的定义，此条以下此宏不再适用。

注意：头文件的函数原型的形式参数是不需要名字而只需要类型的，这跟C++不同，在实现时才声明变量名。

前缀类：

1.volatile   代表易变变量。在变量类型前声明，会避免的编译器进行代码优化，会一条一条照纸面来进行编译。精确地说就是，编译器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。

声明一个volatile变量是编译器的一个指令。编译器是一个将你的C/C++代码转换成机器码的软件，机器码是arduino上的Atmega芯片能识别的真正指令。

具体来说，它指示编译器编译器从RAM而非存储寄存器中读取变量，存储寄存器是程序存储和操作变量的一个临时地方。在某些情况下，存储在寄存器中的变量值可能是不准确的。

如果一个变量所在的代码段可能会意外地导致变量值改变那此变量应声明为volatile，比如并行多线程等。在arduino中，唯一可能发生这种现象的地方就是和中断有关的代码段，成为中断服务程序。

2.(type)expression   在变量或者表达式之前加上（变量类型），可以将变量或者表达式转化为括号内的变量类型。

数字I/O类：

（1）语法：pinMode(pin,mode)
//pin为串口号，表示为0~13，可以使用变量代替，mode表示为INPUT或者OUTPUT

说明：数字类型的IO口输入输出的模式定义函数。例如：LED灯应当设置为输出模式，而传感器应当设置为输入模式。

（2）语法：digitalWrite(pin,value)
//pin为串口号，表示为0~13，value为电平，表示为HIGH或者LOW，代表使串口电平更改为指定的水平。

说明：数字类型的IO口对输出电平的定义函数。比如定义HIGH可以驱动LED。

（3）语法：int digitalRead(pin)
//pin为串口号，表示为0~13

说明：数字类型的IO口对输入电平的读取函数。比如可以读数字传感器。

模拟I/O类：

（1）语法：analogRead(pin)
//pin为模拟串口号，表示为A0~A5（Arduino UNO为A0~A5）返回值范围为0~1024。

说明：模拟类型的IO口对传感器的读取。比如可以读模拟传感器（10位AD，0~5V表示为0~1023）

（2）语法：analogWrite(pin,value)
//pin表示为3，5，6，9，10，11，value表示为0~255，控制电机的PWM脉冲的占空比（而舵机范围为0~180，对应角度）

说明：模拟类型的PWM数字IO口的PWM输出函数，Arduino的数字IO口中标注了PWM(~符号)的数字IO口可使用这个函数。比如可用于电机PWM调速或音乐播放。

（3）语法：analogReference(type)

//设定用于模拟输入的基准电压（输入范围的最大值）。type可选值为：DEFAULT（5v或3.3V版形）、INTERNAL（ATmega168或ATmega328上等于1.1V，在ATmega8上等于2.56V，不适用于Arduino Mega）、INTERNAL1V1（内置1.1V参考，仅限Arduino Mega）、INTERNAL2V56（内置2.56V参考，仅限Arduino Mega）、EXTERNAL（施加到AREF引脚的电压用作参考，必须在0~5V中，不然有可能烧板）。改变基准电压后，包含read功能的函数数据可能不正确。

扩展I/O类：

（1）语法：shiftOut(dataPin,clockPin,bitOrder,value)

//dataPin为数据口，clockPin为时钟口，bitOrder为数据传输方向（MSBIFRST高位在前，LSBFIRST低位在前，value表示所要传送的数据（0~255）

说明：SPI外部IO扩展函数，通常使用带SPI接口的74HC595芯片做8个IO扩展。另外还需要一个IO口做芯片的使能控制。

（2）语法：unsigned long pulseln(pin,value)

说明：脉冲长度（时间）记录函数，返回时间参数（单位us），pin表示为0~13，value为HIGH或者LOW。比如value为HIGH，那么当pin输入为高电平时，开始计时，当pin 输入为低电平时，停止计时，然后返回该时间。

时间函数：

（1）语法：unsigned long millis()

说明：返回时间函数（单位ms），该函数是当所在程序运行就开始计时并返回记录的函数的参数， 返回Arduino开发板运行当前程序开始的毫秒数，该参数要滥出（归零）大约需要50天。

（2）语法：delay()

说明：延时函数（单位ms）。

（3）语法：delayMicroseconds()

说明：延时函数（单位us）。

数学函数：

（1）语法：min(x,y)

说明：取最小值。

（2）语法：max(x,y)

说明：取最大值。

（3）语法：abs(s)

说明：计算并取绝对值。

（4）语法：constrain(x,a,b)

说明：约束函数，下限为a，上限为b，x必须在a和b之间才能返回。

（5）语法：map(value,fromLow,fromHigh,toLow,toHigh)

说明：映射函数，把value从[fromLow,fromHigh]映射到[toLow,toHign]范围中（应该是按照一定比例映射）

（6）语法：pow(base,exponent)

说明：开方函数，取base的exponent次方。

（7）语法：sq(x)

说明：取x的平方。

（8）语法：sqrt(x)

说明：取根号x。

三角函数：

（1）语法：sin(x)

说明：取sinx。

（2）语法：cos(x)

说明：取cosx。

（3）语法：tan(x)

说明：取tanx。

外部中断函数：

（1）语法：attachInterrupt(interrupt,function,mode)

说明：外部中断函数只能用于数字IO口2和3（中断口），这两个是外部中断引脚。当中断函数发生时，delya()和millis()的数值将不会继续变化。当中断发生时，串口收到的数据可能会丢失。你应该声明一个变量来在未发生中断时储存变量。

interrupt：一般使用digitalPinToInterrupt(pin)代替，其中pin是对象电机串口，digital pin to interrupt不就是"要实行中断的引脚"吗？所以interrupt表明了传入中断号的引脚的号数。

function：中断发生时调用的函数，此函数必须不带参数和不返回任何值，有时候也被称为“中断服务函数”。

mode：LOW表示引脚低电平则触发中断，HIGH表示引脚高电平则触发中断（Arduino Due板子才有），CHANGE表示引脚电平发生变化则触发中断，RISING表示引脚电平由低到高（上升沿）则触发中断，FALLING表示引脚电平由高到低（下降沿）则触发中断。

HIGH当引脚为高电平时，触发中断。

LOW 当引脚为低电平时，触发中断。

CHANGE 当引脚电平发生改变时，触发中断。

RISING 当引脚由低电平变为高电平时，触发中断。

FALLING 当引脚由高电平变为低电平时，触发中断。

外部中断是在遇到上述的mode时中断主函数的运行而跳转到指定的函数，执行完之后再跳转回来。

（2）语法：detachinterrupt(interrupt)

说明：中断开关，interrupt=1开，interrupt=0关。 发挥了直接取消中断的作用（不中断会一直执行）。一般使用digitalPinToInterrupt(pin)代替，其中pin是对象电机串口，值不一定是0或者1。这个东西表明了传入中断号的引脚的号数。

（3）语法：digitalPinToInterrupt(pin)

说明：传入引脚pin的中断号（外部中断信号），pin表示串口号，可以是一个代表整数的变量。这个整个函数代表了一个负责传入中断信号的引脚的号数。

中断使能函数：

（1）语法：interrupts()

说明：使能中断。

（2）语法：noInterrupts()//注意是大写的"i"

说明：禁止中断。

串口收发函数（通信函数，用于使Arduino和其他设备进行通信）：

（1）语法：Serial.begin(speed)

说明：串口定义（初始化）波特率函数，speed表示波特率，如9600，19200等。将穿行数据传输速率设置为：位/秒（波特）。与计算机进行通信时，可以通过使用这些波特率：300，1200，2400，4800，9600，14400等等。写在setup函数内的第一行进行声明。

（2）语法：int Serial.available()

说明：判断缓冲器状态。若串口缓冲器有数据可以读取，则"Serial.available">0。有数据可以读取就用read读取。

（3）语法：int Serial.read()

说明：读串口并返回收到参数给计算机端口（串口监视器中显示）。

（4）语法：Serial.flush()

说明：清空缓冲器。

（5）语法：Serial.print(data)

说明：串口输出数据。将数据发送给计算机的串口，计算机端口接收。

（6）语法：Serial.println(data)

说明：串口输出数据并带回车符。将数据发送给计算机的串口，计算机端口接收。

（7）语法：Serial.parseInt()

说明：

标准库头文件函数的应用：

1.<Stepper.h>头文件的"stepper"类的成员函数：

控制步进电机的标准库（其实可以不调用也能驱动步进电机，就是麻烦一点）

（1）语法：

Stepper  Objectname(steps,pin1,pin2)//电机n相时使用，参数为直到后面的pin下标为n为止，一般是pin1到pin2（二相）和pin1到pin4（四相）。steps是设置所使用的电机转一周需要的步数（脉冲数，例如当steps为200时步长为1.8度），这个函数需要在setup函数以前写。

Stepper Objectname(steps,pin1,pin2,pin3,pin4)//四相步进电机的格式。

（2）语法：

Objectname.setSpeed(rpms)//这个是控制转速的函数，实际是脉冲频率。参数rpms单位为rpms，为每分钟电机转的圈数。数值为正整数。该函数不会使电机旋转，仅仅是设定。

（3）语法：

Objectname.step(steps)//这个函数是使电机的转子转过固定的步数steps，只有当转子也就是内部转轴转过指定步数之后才会执行该语句的下一条语句。参数steps应该是整数，正负号控制旋转方向。对应角度的所需步数可以通过不同电机的参数计算得出。

某型号的角度对应（具体要进行计算）：

转子旋转一周需要走32步（硬件具体参数）。转子每旋转一周，电机输出轴只旋转1/64周。（减速比）

电机内部配有多个减速齿轮,这些齿轮会的作用是让转子每旋转一周，输出轴只旋转1/64周。

因此电机输出轴旋转一周则需要转子走32*64=2048步

因此：

steps=5.68888  旋转1度

steps=170.666  旋转30度

steps=256      旋转45度

steps=341.333  旋转60度

steps=512      旋转90度

steps=1024     旋转180度

steps=2048     旋转360度

2.<Servo.h>头文件的"Servo"类的成员函数：

控制舵机的标准库（其实可以不调用也能驱动舵机，就是麻烦一点）。

（1）语法：

Objectname.attach(pin)//连接舵机，在Arduino 0016及之前的版本上，Servo库仅支持将舵机连接至第9和第10脚上，Objectname为对象名字，pin为舵机所在的串口

Objectname.attach(pin,min,max)//min(可选)，舵机为最小角度（0度）时的脉冲宽度，单位为微秒，默认为544。max(可选)，舵机为最大角度（180度时）的脉冲宽度，单位为微秒，默认为2400

（2）语法：

Objectname.write(value)//角度控制，Objectname为对象名字，value为0~180，对应旋转的角度的度数

（3）语法：

Objectname.writeMicroseconds(us)//用于设定舵机旋转角度的语句，直接用微秒作为参数，Objectname为对象名字，us为一个代表微秒值的整数参数

（4）语法：

Objectname.read()//读上一次舵机转动角度，用于读取对象的舵机角度的语句，可理解为读取最后一条write()命令中的值（也就是Arduino上一次发送的值，仍然不是真实值），返回角度值（0~180），Objectname为对象名字，无参数

（5）语法：

Objectname.attached()//判断舵机参数是否已发送到对象的舵机所在接口，也就是等于检查一个servo变量是否被附加到一个引脚，如果被附加到一个引脚则返回true，反之返回false，Objectname为对象名字，无参数

（6）语法：

Objectname.detach()//断开舵机连接，使舵机与其接口分离，该接口（标有~的数字的接口）可继续被用作PWM接口，Objectname为对象名字，无参数

3.<EEPROM.h>头文件的"EEPROM"类的成员函数：

Arduino开发板上的微控制器带有EEPROM（电可擦除可编程只读存储器）。存储于EEPROM中的信息不会因为Arduino断电而丢失（这就好像 一个小U盘一样）。通过EEPROM，我们可以存储需要长久保存的变量数值或其它数据信息。EEPROM库可以让用户轻松的读取和写入Arduino开发板的EEPROM。

EEPROM的主要操作为读取和写入。但是EEPROM的 每一个地址可以存储的信息为1字节，这就限制了EEPROM的每一个地址内所能单独存储的整数数值为0~255区间。由于EEPROM.read()以及EEPROM.write()每一次只能读或写一个字节的数据, 假如我们需要存储超出0~255范围的整数数值或者带有小数点的浮点数，就需要用多个EEPROM协作存储来完成。

（1）语法：EEPROM.read(address,value)//读取EEPROM中存储的信息，address为地址（整型），value为存储的值（整型或者浮点型）

（2）语法：EEPROM.write(address,value)//向EEPROM中写入信息，address为地址（整型），value为存储的值（整型或者浮点型），常用

（3）语法：EEPROM.put(address,value)//向EEPROM储存数据，address为地址（整型），value为存储的值（整型或者浮点型），常用

（4）语法：EEPROM.get(address,value)//获取EEPROM储存的数据，address为地址（整型），value为存储的值（整型或者浮点型），常用

（5）语法：EEPROM.update()//更新EEPROM存储内容

4.<SD.h>头文件的"SD"类的成员函数：

（1）语法：

（2）语法：

（3）语法：

（4）语法：

（5）语法：

5.<Wire.h>头文件的"Wire"类的成员函数：

（1）语法：

Wire.setclock(a);//设置i2c设备的通信频率，如果想要加快速度，可以将a设置为400000也就是400kHz i2c模式，但是有些i2c设备不适合使用这个频率设置。

（2）语法：

（3）语法：

（4）语法：

（5）语法：

6.<LiquidCrystal.h>头文件的"lcd"类的成员函数：

（1）语法：

（2）语法：

（3）语法：

（4）语法：

（5）语法：

7.<SPI.h>头文件的"SPI"类的成员函数：

串行外围设备接口（SPI）是微控制器使用的同步串行数据协议，用于在短距离内快速与一个或多个外围设备进行通信。它也可以用于两个开发板之间相互的通信。

使用SPI连接，总是有一个主设备（通常是微控制器）来控制外围设备。通常，所有设备共用以下三条线：

MISO（Master In Slave Out）从机线路，用于向主机发送数据。

MOSI（Master Out Slave In）主机线路，用于向外围设备发送数据。

SCK（串行时钟）同步主机产生的数据传输的时钟脉冲。

每个从设备专用的一条线：

SS（从设备选择）主设备可用此引脚来决定启用或禁用指定设备。

当从设备的CS引脚为低电平时，它与主机通信。同理CS引脚电平为高时，它将忽略连接到CS引脚的设备, 不与之进行数据交互。

基于AVR的板上的从选择（SS）引脚的说明

所有基于AVR的板都有一个SS引脚，当它们充当由外部主机控制的从机时，该引脚很有用。由于该库仅支持主模式，因此该引脚应始终设置为OUTPUT，否则硬件会自动将SPI接口设置为从模式，从而使库无法工作。

此外，您也可以将任何引脚用作从设备的选择引脚（SS）。例如，Arduino以太网扩展板使用引脚10控制到板载SD卡的SPI连接，并使用引脚10控制到以太网控制器的连接。

成员函数：

（1）语法：SPI.end()//

（2）语法：SPI.beginTransaction( SPISettings(14000000, MSBFIRST, SPI_MODE0) )

（3）语法：

（4）语法：

（5）语法：

第三方库：

<Adafruit_PWMServoDriver.h>头文件"Adafruit_PWMServoDriver"类的成员函数：

（1）语法：

Adafruit_PWMServoDriver Object=Adafruit_PWMServoDriver(address);

Adafruit_PWMServoDriver Object=Adafruit_PWMServoDriver(address,wire);

//address为PCA板子的虚拟i2c的7位地址，如0x41（默认地址为0x40，地址为0x40+A5:A0，An接地不做处理则为0，address为空则为默认地址就是第一块板子而不是下属的级联板子）。这整个函数代表了一个初始地址值，在声明对象时应被赋给对象。

（2）语法：

Object.begin();//初始化对象，每个程序都需要进行一次。这里的对象Object是一整个板子而不是一个PWM接口。

（3）语法：

Object.setPWMFreq(H);//Hz代表设定的PWM输出的频率。

模拟伺服电机在H赫兹更新下运行（每秒的更新速度）。1600Hz是PCA9865板子的最大的PWM频率。用来调节PWM频率。一般以40-1000Hz为PWM的频率范围。1/Hz为每个脉冲的周期时间长度。

（4）语法：

Object.setServoPulse(a,b);//设置舵机的脉冲，a为通道，对应板子上的接口。b为时间，通过微秒数来控制舵机转动的角度，一般为500-2500us对应0-180度的PWM占空比对应0-180度。

（5）语法：

Object.setPWM(a,b,c);//a为通道，为0-15，对应板子上的接口，也就是表示PWM操控的对象接口。第二个参数b是代表脉冲起始时间，第三个c代表脉冲结束时间，如果第二个参数设置是0，那么第三个参数就等价于是脉冲长度。b为当信号从低电平变为高电平时的tick（0~4095），一般为0（为什么呢？）。c为当信号从高电平变为低电平时的tick（0~4095），填入角度对应的寄存器值（也就是高电平占空比乘分辨率的值，说明在12bit下每个周期分为4095个部分，c填入多少个部分决定了每个周期的高电平的占的部分，也就是占空数），寄存器值的计算公式：

舵机的控制一般需要一个20ms的时基脉冲，该脉冲的高电平部分一般为0.5ms~2.5ms范围内的角度控制脉冲部分。以180度角度舵机为例，那么对应的控制关系是这样的：

0.5ms————–0度；
1.0ms————45度；
1.5ms————90度；
2.0ms———–135度；
2.5ms———–180度；

PCA9685可以设置更新频率，时基脉冲周期20ms相当于50HZ更新频率。PCA9685采用12位的寄存器来控制PWM占比，对于0.5ms，相当于0.5/20*4096=102的寄存器值。以此类推如下：

0.5ms————–0度：0.5/20*4096 = 102
1.0ms————45度：1/20*4096 = 204
1.5ms————90度：1.5/20*4096 = 306
2.0ms———–135度：2/20*4096 = 408
2.5ms———–180度：2.5/20*4096 =510

注意：但是实际使用的时候，还是有偏差，除了0度以及180度，其他需要乘以0.915系数。最后的寄存器值如下：
0.5ms————–0度：0.5/204096 = 102
1.0ms————45度：1/204096 = 204 * 0.915 = 187
1.5ms————90度：1.5/204096 = 306 * 0.915 = 280
2.0ms———–135度：2/204096 = 408 * 0.915 = 373
2.5ms———–180度：2.5/20*4096 =510

实例：

The following example will cause channel 15 to start low, go high around 25% into the pulse

(tick 1024 out of 4096), transition back to low 75% into the pulse (tick 3072), and remain low

for the last 25% of the pulse：

下列的例子会将第15通道的舵机从低电平开始到高电平的占比为1024/4096=25%，然后

setPWM(15, 1024, 3072);//低电平占25%，高电平占75%

（6）语法：

Object.setPin(a,b,c);//旧版本拥有。

（7）语法：

Object.setOscillatorFrequency(a);//这个函数可以设置Object的PCA9865板子的内部时钟晶振的频率，一般用于对其的初始化。因为默认应当为25Hz但是它默认来说一般不会这么精确，可能到23Hz-27Hz。因此在调整到预期的PWM频率(例如模拟舵机需要50Hz的PWM输入)之前，必须不断对a进行调整。内部时钟用于实现writeMicroseconds()和PWM频率输出等功能，因此错误的a会导致PWM结果的错误。a=27000000为给PWM50Hz的标准值。

（8）语法：

yield();//ESP8266板子需要在程序结尾使用的函数，出处未知，作用未知。

（9）语法：

Object.readPrescale();//读取连接的板子的预分频值。

***

### 算法

#### PID算法

对电机的PID也是用Arduino编写即可。详情见PID笔记。

while语句的结尾为";"语句算法：

这是一个写法，也是一个用法。

下面看一个实例：

while(n++<60);//注意，直接加分号，应该是等于无效语句。但是，在前面有某些设定即持续生效的函数时，这个语句就等价于等待60个循环的时间，本质上是一个延时函数。

下面，通过Arduino的自带库中的中断函数来进行演示。

void ADD( )

{Number++;//每次执行进行自增，用于计算圈数}

n=millis()+60;//定义一个比现在多60毫秒的变量，用于延长时间，millis()是每毫秒都会进行自增的函数

attachInterrupt(digitalPinToInterrupt(3),ADD,RISING);//绑定中断口"3"，每当3口电平满足RISING，执行一次函数ADD，函数ADD不需要括号。这里可以看出，当程序执行到这一语句时，整个程序就被"附加"上了一个RISING判断，此时其他程序继续运行，但只要编码器电平一满足RISING，就会执行一次函数ADD。

while(millis()<n);//重点来了，通过这一句while语句，直到millis()的数值等于n，也就是经过60毫秒，系统一直会在中断判定的背景下运行，每次判定成功都会进行一次ADD函数，到直到millis()的数值等于n时，这条while语句结束。也就是程序可以开始执行while后面的语句了。可能有疑问：Arduino不能执行多线程，那只测速轮子不转了怎么办？难道测惯性？首先，60毫秒连0.01秒都不到，很难感受出来。然后，设置PWM的analogWrite的PWM输出是跟拉高拉低电平是一样是持续性的。也就是说测速的时候测的是上一个周期输出的固定的一直保留的PWM值驱动的轮子的速度，因此测速时轮子依然在转。

detachinterrupt(3);//解绑3号的中断，也就是不再进行中断的监督，Number不再自增。